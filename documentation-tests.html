<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests</title>
    <style>
    body {background-color: rgba(255, 160, 211, 0.68);}
    h2   {color: rgb(255, 255, 255);
            font-family: verdana;
            font-size: 120%;
            font-weight: bold;}
    p   {color: rgb(4, 4, 4);
        font-family: verdana;
        font-size: 100%;}

    a   {color: rgb(125, 6, 113);
        font-family: verdana;
        font-size: 100%;}

    ul {color: rgba(38, 1, 33, 0.98);
            font-family: verdana;
            font-size: 110%;}
    </style>
</head>
<body>


    <h2>Méthodes Testées</h2>


    <h3><a href=" src/test/java/com/marginallyclever/makelangelo/rangeslider/RangeSliderTest.java ">RangeSliderTest.java
    </a></h3>
    <ul>
        <p>1.</p>
        <li>SetUpperValue()</li>
        <p>
            On a choisi de tester la méthode setUpperValue dans le contexte de RangeSlider pour nous assurer que les
            valeurs dépassant la plage autorisée sont correctement gérées. Cela me permet de valider que les limites
            sont respectées, de maintenir la cohérence de l'état interne de l'objet et de prévenir les erreurs
            potentielles des utilisateurs.
        </p>
    </ul>


    <h3>ActionCommandDialogTest</h3>
    <ul>
        <p>2.</p>
        <li>SaveResult_NullSelection</li>
        <p>
            Raison de tester cette méthode :
            La classe ActionCommandDialog est utilisée pour gérer les entrées utilisateur, ce qui constitue une partie
            essentielle de l'interaction dans de nombreuses applications.Ce test assure la robustesse du code, évitant
            ainsi les erreurs ou exceptions potentielles dues à l'absence de sélection. En vérifiant ce cas limite,
            les développeurs peuvent s'assurer que le comportement du programme reste cohérent et fiable dans
            différentes situations d'utilisation.
            On a choisi de tester la méthode SaveResult dans le contexte de ActionCommandDialog pour nous assurer que
            les fonctionnalités de la boîte de dialogue fonctionnent correctement, offrant une bonne expérience
            utilisateur et améliorant la qualité globale du logiciel.
        </p>
        <p>3.</p>
        <li>SaveResult_WithChoices</li>
        <p>
            Raison de tester cette méthode :
            Étant donné que cette classe concerne les entrées utilisateur et le choix d'options, tester cette classe
            est crucial pour garantir que le programme répond avec précision aux actions de l'utilisateur. Cela
            contribue à assurer la fiabilité du logiciel lors du traitement des interactions utilisateur.
            On a choisi de tester la méthode SaveResult dans le contexte de ActionCommandDialog pour garantir que,
            lorsque des options sont présentes, la méthode peut correctement identifier et retourner le choix de
            l'utilisateur. Cela représente une partie essentielle de l'interaction utilisateur, et valider cette
            fonctionnalité peut éviter des erreurs logiques ou des incohérences dans les données dues à un choix
            incorrect.
        </p>
    </ul>


    <h3>StringHelper.java</h3>
    <ul>
        <p>4.</p>
        <li>FormatFloat</li>
        <p>
            Raison de tester cette méthode :
            Ce test s'assure qu'il formate correctement une valeur de type float en une chaîne
            de caractères avec trois décimales, il est crucial de conserver un nombre précis de décimales.
            On a choisi de tester la méthode FormatFloat dans le contexte de StringHelper pour garantir que
            la valeur float est toujours formatée conformément aux attentes, avec une localisation
            spécifiquement américaine(Locale.US).</p>

        <p>5.</p>
        <li>FormatDouble</li>
        <p>
            Raison de tester cette méthode :
            Cette méthode de test StringHelper.formatDouble() vérifie qu'une valeur de type double est correctement
            formatée avec trois décimales.
            On a choisi de tester la méthode FormatDouble dans le contexte de StringHelper pour s'assurer que
            la méthode produit une sortie formatée de manière cohérente, similaire à formatFloat.</p>

        <p>6.</p>
        <li>GetElapsedTime</li>
        <p>
            Raison de tester cette méthode :
            Cette méthode de test StringHelper.getElapsedTime() vérifie que le nombre de secondes est correctement
            converti en une chaîne de caractères au format HH:mm:ss.
            On a choisi de tester la méthode paddedHex dans le contexte de StringHelper pour s'assurer que la conversion
            du temps est correcte, évitant ainsi toute erreur d'affichage du temps dans les applications.
        </p>



    </ul>

    <h3>TextInterfaceToListeners.java</h3>

    <ul>
        <p>7.</p>
        <li>SendCommand</li>
        <p>
            Raison de tester cette méthode :
            Cette méthode de test vérifie si la méthode sendCommand() déclenche correctement un ActionListener et
            si la commande transmise correspond à celle attendue.
            On a choisi de tester la méthode SendCommand dans le contexte de TextInterfaceToListeners pour garantir que
            lorsque la méthode sendCommand() est appelée, les écouteurs enregistrés peuvent traiter correctement
            la commande transmise. Cela est essentiel pour assurer la bonne transmission et le traitement des
            événements.</p>

        <p>8.</p>
        <li>GetCommand</li>
        <p>
            Raison de tester cette méthode :
            Cette méthode de test vérifie si la méthode getCommand() peut récupérer correctement la commande saisie
            par l'utilisateur.
            On a choisi de tester la méthode getCommand dans le contexte de TextInterfaceToListeners pour garantir que
            la commande saisie par l'utilisateur peut être correctement récupérée et traitée, ce qui est très important
            pour assurer le bon fonctionnement de l'entrée et de la sortie de l'interface utilisateur.</p>


    </ul>


    <h3><a href="src/test/java/com/marginallyclever/makelangelo/plotter/plottercontrols/CartesianButtonsTest.java">
        CartesianButtonsTest.java</a></h3>
    <ul>
        <p>9.</p>
        <li>getZone(int)</li>
        <p>Nous avons choisi d'effectuer ce test pour nous assurer que le système classe correctement les points en
            différentes zones, ce qui est essentiel pour manipuler des graphiques ou des contrôles dans un espace
            cartésien. De plus, la distinction entre le centre et les autres zones est importante pour déterminer le
            comportement du système.</p>

        <p>10.</p>
        <li>getQuadrant(int)</li>
        <p>Nous pensons que ce test est nécessaire car dans ce système de contrôle basé sur des coordonnées
            cartésiennes, identifier le bon quadrant est essentiel pour déterminer la direction ou la position relative
            d'un point. Si la méthode renvoie des résultats incorrects, cela peut affecter la logique de mouvement ou
            d'affichage dans l'espace.</p>
        <li>isCenterZone(int)</li>
        <p>Nous avons choisi de faire ce test car il est crucial de s'assurer que le système peut différencier la zone
            centrale des autres zones de l'espace cartésien. Ceci est important car le système dépend d'un emplacement
            précis dans un espace graphique et de contrôle, garantissant que les calculs de position sont effectués
            correctement.</p>
    </ul>

    <h3><a  href="src/test/java/com/marginallyclever/makelangelo/select/SelectPasswordTest.java">
        SelectPasswordTest.java</a></h3>
    <ul>
        <p>11.</p>
        <li>testGetPassword()</li>
        <p>Nous avons choisi ce test qui récupère le mot de passe et renvoie la bonne valeur qui lui a été attribuée.
            Nous trouvons cela important car si la méthode renvoie une valeur incorrecte, cela peut entraîner des
            problèmes de fonctionnalité ou de sécurité.</p>

        <p>12.</p>
        <li>testIsEditable()</li>
        <p> Nous avons choisi de tester cette méthode pour nous assurer que le champ du mot de passe peut être modifié,
            ce qui est crucial pour la convivialité du système. Si cette méthode échoue, des problèmes peuvent survenir
            dans l'interface utilisateur, empêchant les utilisateurs de modifier le mot de passe lorsqu'ils sont censés
            le faire.</p>
    </ul>

    <ul>
        <h3>ColorHSB.java</h3>
        <p>13.</p>
        <li>ColorHSBSetMethod()</li>
        <p>
            Raison de tester cette méthode :
            On a choisi de tester la méthode ColorHSBSetMethod parce qu'elle peut être utilisée pour modifier l'état
            de l'objet. Si elle ne fonctionne pas correctement, des résultats incorrects peuvent être produits
            lors des appels à d'autres méthodes. Ce test s'assure que la méthode set() respecte les contraintes de
            valeurs comprises entre 0 et 1.
        </p>
    </ul>

    <ul>
        <p>14.</p>
        <li>ColorHSBDiffMethod()</li>
        <p>
            Raison de tester cette méthode :
            On a choisi de tester la méthode ColorHSBDiffMethod parce qu'elle est utile pour mesurer à quel point
            deux couleurs sont proches ou éloignées. Tester cette méthode est crucial car le calcul de la différence
            entre deux couleurs peut être utilisé dans divers algorithmes ou fonctionnalités où la similarité ou
            la dissimilarité des couleurs est importante. Le test s'assure que la différence calculée correspond à
            la valeur attendue, en prenant en compte une petite marge d'erreur (delta) à cause des imprecisions
            liées aux nombres flottants.
        </p>
    </ul>

</body>
</html>
